PARSER_BEGIN(MoolMinusParser)package parser;import java.util.*;import class_elements.*;import parser_structures.*;import com.microsoft.z3.*;import logic.*;public class MoolMinusParser{  static boolean parser_context = false;  static HashMap < String, String > cfg = new HashMap < String, String > ();  static  {    cfg.put("proof", "true");  }  static Context ctx = new Context(cfg);  static Token class_name;  static HashMap < String, MoolClass > mool_classes = new HashMap < String, MoolClass > ();  static HashMap < String, List < MoolMethod >> mool_classes_methods = new HashMap < String, List < MoolMethod >> ();  static HashMap < String, String > class_fields = new HashMap < String, String > ();  static HashMap < String, String > local_variables = new HashMap < String, String > ();  static HashMap < String, String > method_params = new HashMap < String, String > ();  //static Expr invariant, initial;  static ASTNode invariant, initial;  static ASTNode constructor_requires = new ASTTrue(ctx);  static Token constructor_name; //, constructor_body;  static ASTNode constructor_body;  static Token method_name, method_body;  static MoolClass mool_class;  static List < MoolMethod > methods = new ArrayList < MoolMethod > ();  static List < MoolField > fields = new ArrayList < MoolField > ();  static List < MoolField > params = new ArrayList < MoolField > ();  static List < MoolField > vars = new ArrayList < MoolField > ();  static List < MoolField > constructor_params = new ArrayList < MoolField > ();  static List < MoolField > constructor_vars = new ArrayList < MoolField > ();  static ASTNode field_requires;  static boolean constructor_context = false;  static String mool_class_name;  static int method_counter = 0;  public Map < String, MoolClass > getMoolClasses()  {    return mool_classes;  }  public Context getSolverContext()  {    return ctx;  }  public void setParserContext(boolean parser_context)  {    this.parser_context = parser_context;  }}PARSER_END(MoolMinusParser)SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < CLASS : "class" >| < UNRESTRICTED : "unrestricted" >| < LBRACKET : "{" >| < RBRACKET : "}" >| < LPAR : "(" >| < RPAR : ")" >| < INV : "//@ invariant " >| < INIT : "//@ initial " >| < REQ : "//@ requires " >| < ENS : "//@ ensures " >  //| < CLASS_INIT : "init" >| < SYNC : "sync" >| < NEW : "new" >| < VOID_TYPE : "void" >| < INTEGER_TYPE : "int" >| < BOOLEAN_TYPE : "boolean" >| < STRING_TYPE : "string" >| < TRUE : "true" >| < FALSE : "false" >| < NULL : "null" >| < THIS : "this" >| < UNIT : "unit" >  //| < EMPTY : "" >| < IF : "if" >| < ELSE : "else" >| < PRINTSTR : "printStr" >| < PRINTINT : "printInt" >| < SPAWN : "spawn" >| < ID : [ "a"-"z", "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >| < STRING :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )*    "\"" >| < INTEGER : ([ "0"-"9" ])+ >| < OR : "||" >| < AND : "&&" >| < NOT : "!" >| < IMPLIES : "->" >| < EQUAL : "==" >| < DIFF : "!=" >| < GREATER : ">" >| < LESS : "<" >| < GREATER_OR_EQUAL : ">=" >| < LESS_OR_EQUAL : "<=" >| < DOT : "." >| < ASSIGN : "=" >| < PLUS : "+" >| < MINUS : "-" >| < MULT : "*" >| < DIV : "/" >| < CONCAT : "++" >| < COMMA : "," >| < L : ";" >}void Start() throws Exception :{}{  (    Class()  )+}void Class() throws Exception :{  methods = new ArrayList < MoolMethod > ();  fields = new ArrayList < MoolField > ();  method_counter = 0;  Token n = null;}{  (  n = < UNRESTRICTED >)?< CLASS > class_name = < ID > < LBRACKET >  (    Fields(0) < L >  )*  (    Constructor()  )?  (    Methods()  )* //Can be zero because of unrestricted classes with constructor only, like Main  < RBRACKET >  {    if (parser_context)    {      mool_classes.put(class_name.image, new MoolClass(class_name.image, (n != null),null, null, constructor_name.image, constructor_body, methods, fields, constructor_params, constructor_vars));      mool_classes_methods.put(class_name.image, methods);    }  }}void Methods() throws Exception :{  //Token method_name = null;  Token method_type;  ASTNode method_body;  ASTNode method_requires, method_ensures;  boolean is_sync = false;  local_variables = new HashMap < String, String > ();  method_params = new HashMap < String, String > ();  params = new ArrayList < MoolField > ();  vars = new ArrayList < MoolField > ();  method_counter++;}{  < REQ > method_requires = AssertionOr(true) < L > < ENS > method_ensures = AssertionOr(false) < L > (< SYNC > { is_sync = true; })? method_type = Types() method_name = < ID > < LPAR >  (    Fields(2)    (      < COMMA > Fields(2)    )*  )?  < RPAR > < LBRACKET > method_body = SyntaxConditional() < RBRACKET >  {    if (parser_context)    {      methods.add(0, new MoolMethod(method_name.image, method_type.image, is_sync, null, null, method_body, params, vars));    }    else    {      mool_classes.get(class_name.image).getMethod(method_name.image).setMethodRequires(method_requires);      mool_classes.get(class_name.image).getMethod(method_name.image).setMethodEnsures(method_ensures);    }  }}Token Types() :{  Token n;}{  (    n = < VOID_TYPE >  | n = < BOOLEAN_TYPE >  | n = < INTEGER_TYPE >  | n = < STRING_TYPE >  | n = < ID >  )  {    return n;  }}ASTNode Fields(int mode) :{  Token n1, n2;  MoolField f = null;}{  n1 = Types() n2 = < ID >  {    switch (mode)    {      case 0 : class_fields.put(n2.image, n1.image);      f = new MoolField(n2.image, n1.image, true, class_name.image);      fields.add(f);      break;      case 1 : local_variables.put(n2.image, n1.image);      if (constructor_context)      {        f = new MoolField(n2.image, n1.image, false, class_name.image);        constructor_vars.add(f);      }      else      {        f = new MoolField(n2.image, n1.image, false, method_name.image);        vars.add(f);      }      break;      case 2 : method_params.put(n2.image, n1.image);      if (constructor_context)      {        f = new MoolField(n2.image, n1.image, false, class_name.image);        constructor_params.add(f);      }      else      {        f = new MoolField(n2.image, n1.image, false, method_name.image);        params.add(f);      }      break;    }    return new ASTField(n2.image, n1.image, (mode == 1), f, ctx);  }}void Variables() :{  Token n1, n2;}{  n1 = Types() n2 = < ID > < L >  {    local_variables.put(n2.image, n1.image);  }}void Constructor() throws Exception :{  local_variables = new HashMap < String, String > ();  method_params = new HashMap < String, String > ();  constructor_params = new ArrayList < MoolField > ();  constructor_vars = new ArrayList < MoolField > ();  constructor_context = true;}{  //< INV > invariant = AssertionOr() < L > < INIT > initial = AssertionOr() < L > < VOID_TYPE > constructor_name = < ID > < LPAR > < RPAR > < LBRACKET > constructor_body = < INTEGER > < RBRACKET >  //< INV > invariant = AssertionOr() < L > < INIT > initial = AssertionOr() < L > < VOID_TYPE > constructor_name = < ID > < LPAR > < RPAR > < LBRACKET > constructor_body = SyntaxSeq() < RBRACKET >  < INV > invariant = AssertionOr(true) < L >  (    < REQ > constructor_requires = AssertionOr(true) < L >  )?  < INIT > initial = AssertionOr(false) < L > < VOID_TYPE > constructor_name = < ID > < LPAR >  (    Fields(2)    (      < COMMA > Fields(2)    )*  )?  < RPAR > < LBRACKET > constructor_body = SyntaxConditional() < RBRACKET >  {    constructor_context = false;    if (!parser_context)    {      mool_classes.get(class_name.image).setClassInvariant(invariant);      mool_classes.get(class_name.image).setClassInitialCondition(initial);      mool_classes.get(class_name.image).getClassConstructor().setMethodRequires(constructor_requires);    }  }}ASTNode SyntaxConditional() throws Exception :{  ASTNode t, t1, t2 = null;  Token n, n1, n2;}{  (    < IF > < LPAR > t = SyntaxOr() < RPAR >    (      t1 = SyntaxAssign() < L >      (        < ELSE >        (          t2 = SyntaxAssign() < L >        | < LBRACKET > t2 = SyntaxSeq() < RBRACKET >        )      )?      {        if (t2 != null) t = new ASTIf(t, t1, t2, ctx);        else t = new ASTIf(t, t1, ctx);      }    | < LBRACKET > t1 = SyntaxSeq() < RBRACKET >      (        < ELSE >        (          t2 = SyntaxAssign() < L >        | < LBRACKET > t2 = SyntaxSeq() < RBRACKET >        )      )?      {        if (t2 != null) t = new ASTIf(t, t1, t2, ctx);        else t = new ASTIf(t, t1, ctx);      }    )    (      t2 = SyntaxSeq()      {        t = new ASTSeq(t, t2, ctx);      }    )?  | t = SyntaxSeq()  )  {    return t;  }}ASTNode SyntaxSeq() throws Exception :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = SyntaxSpawn() (      < L >)?  (    t2 = SyntaxConditional()    {      t1 = new ASTSeq(t1, t2, ctx);    }    (      < L >)?  )*  {    return t1;  }}ASTNode SyntaxSpawn() throws Exception :{  ASTNode t1, t2;  Token n, n1, n2;}{  (    t1 = SyntaxAssign()  | < SPAWN > < LBRACKET > t1 = SyntaxSeq() < RBRACKET >  {    t1 = new ASTSpawn(t1, ctx);  })  {    return t1;  }}ASTNode SyntaxAssign() :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = SyntaxOr()  (    < ASSIGN > t2 = SyntaxOr()    {      t1 = new ASTAssign(ctx, t1.toString(), t2); //new ASTSkip(ctx);    }  )?  {    return t1;  }}ASTNode SyntaxOr() :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = SyntaxAnd()  (    < OR > t2 = SyntaxAnd()    {      t1 = new ASTOr(t1, t2, ctx);    }  )*  {    return t1;  }  {}}ASTNode SyntaxAnd() :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = SyntaxNot()  (    < AND > t2 = SyntaxNot()    {      t1 = new ASTAnd(t1, t2, ctx);    }  )*  {    return t1;  }  {}}ASTNode SyntaxNot() :{  ASTNode t, t1, t2;  Token n, n1, n2;}{  (    < NOT > t = SyntaxComp()    {      return new ASTNot(t, ctx);    }  | t = SyntaxComp()    {      return t;    }  )  {}}ASTNode SyntaxComp() :{  ASTNode t = null;  ASTNode t1, t2;  Token op, n, n1, n2;}{  t1 = SyntaxArith()  (    (      op = < EQUAL >    | op = < DIFF >    | op = < GREATER >    | op = < LESS >    | op = < GREATER_OR_EQUAL >    | op = < LESS_OR_EQUAL >    )    t2 = SyntaxArith() ///t2 = Exp()     {      if (op.kind == EQUAL) t1 = new ASTEqual(t1, t2, ctx);      if (op.kind == DIFF) t1 = new ASTDiff(t1, t2, ctx);      else if (op.kind == GREATER) t1 = new ASTGreater(t1, t2, ctx);      else if (op.kind == LESS) t1 = new ASTLess(t1, t2, ctx);      else if (op.kind == GREATER_OR_EQUAL) t1 = new ASTGreaterOrEqual(t1, t2, ctx);      else if (op.kind == LESS_OR_EQUAL) t1 = new ASTLessOrEqual(t1, t2, ctx);    }  )*  {    return t1;  }}ASTNode SyntaxArith() :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  t1 = SyntaxString()  (    (      op = < PLUS >    | op = < MINUS >    | op = < MULT >    | op = < DIV >    )    t2 = SyntaxString() ///t2 = Exp()     {      if (op.kind == PLUS) t1 = new ASTPlus(t1, t2, ctx);      else if (op.kind == MINUS) t1 = new ASTMinus(t1, t2, ctx);      else if (op.kind == MULT) t1 = new ASTMult(t1, t2, ctx);      else if (op.kind == DIV) t1 = new ASTDiv(t1, t2, ctx);    }  )*  {    return t1;  }}ASTNode SyntaxString() :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  (    t1 = SyntaxGroup()  (    < CONCAT > t2 = SyntaxGroup()    {      t1 = new ASTConcat(t1, t2, ctx);    }  )*| < PRINTSTR> < LPAR> t1 = SyntaxGroup() < RPAR>{  t1 = new ASTPrintStr(t1.toString(), ctx);}| < PRINTINT> < LPAR> t1 = SyntaxGroup() < RPAR>{  t1 = new ASTPrintInt(t1.toString(), ctx);})  {    return t1;  }}ASTNode SyntaxGroup() :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  (    < LPAR > t1 = SyntaxOr() < RPAR >  | t1 = SyntaxCall()    (      < CONCAT > t2 = SyntaxCall()      {	        t1 = new ASTConcat(t1, t2, ctx);      }    )*  )  {    return t1;  }}ASTNode SyntaxCall() :{  ASTNode t, t1, t2;  Token op, n, n1, n2;  List < ASTNode > call_params = new ArrayList < ASTNode > ();}{  (    t = SyntaxLiteral()    (      < DOT > n = < ID > < LPAR >      (        t1 = SyntaxOr()        {          call_params.add(t1);        }        (          < COMMA > t1 = SyntaxOr()          {            call_params.add(t1);          }        )*      )?      < RPAR >      {				MoolClass mc = mool_classes.get(class_fields.get(t.toString()));		if(mc == null)		{			mc = mool_classes.get(method_params.get(t.toString()));					}		if(mc == null)			{			  //System.out.println(t.toString() + " :;:;: " + mool_classes.size());			  mc = mool_classes.get(local_variables.get(t.toString()));			}			//System.out.println(t.toString() + "                          " + mc);        if (mc.getMethod(n.image) != null) t = new ASTCall(ctx, t.toString(), n.image, call_params, true, mc.getMethod(method_name.image), mc.getMethod(n.image));        //t = mool_classes.get(class_fields.get(t.toString())).getMethod(n.image).getMethodBody(); //ctx.mkBoolConst(n.image + "_call_on_" + t.toString());              }    | < LPAR >      (        //n1 = < ID >        t1 = SyntaxOr()        {          call_params.add(t1);        }        (          < COMMA > t1 = SyntaxOr()          {            call_params.add(t1);          }        )*      )?      < RPAR >      {        if (parser_context)        {          t = new ASTCall(ctx, "this", t.toString(), call_params, true, null, null);        }      }    )?  | < NEW > t = SyntaxLiteral() < LPAR > (        //n1 = < ID >        t1 = SyntaxOr()        {          call_params.add(t1);        }        (          < COMMA > t1 = SyntaxOr()          {            call_params.add(t1);          }        )*      )?< RPAR >    {      t = new ASTNew(t.toString(), call_params, ctx);    }    /*{      mool_class = mool_classes.get(t.toString());      if (mool_class != null) t = mool_class.getClassInitialCondition(); //ctx.mkBoolConst(n.image + "_call_on_" + t.toString());    }*/  )  {    return t;  }}ASTNode SyntaxLiteral() :{  ASTNode t, t1, t2;  Token n, n1, n2;}{  (    LOOKAHEAD(2)    n = < UNIT >    {      return new ASTUnit(ctx);    }  | n = < TRUE >    {      return new ASTTrue(ctx);    }  | n = < FALSE >    {      return new ASTFalse(ctx);    }    | n = < NULL >    {      return new ASTNull(ctx);    }  | n = < STRING >    {      //return new ASTInteger(n.image.length(), ctx);      return new ASTString(n.image, ctx);    }    | LOOKAHEAD(2)    t = Fields(1)    {      return t;    }  | n = < ID >    {      if (class_fields.containsKey(n.image)) return new ASTField(n.image, class_fields.get(n.image), false, null, ctx);      else if (local_variables.containsKey(n.image)) return new ASTField(n.image, local_variables.get(n.image), false, null, ctx);      else if (method_params.containsKey(n.image)) return new ASTField(n.image, method_params.get(n.image), false, null, ctx);      else if (mool_classes.containsKey(n.image)) return new ASTId(n.image, ctx);      else return new ASTId(n.image, ctx);    }  | n = < INTEGER >    {      return new ASTInteger(Integer.parseInt(n.image), ctx);    }    | < MINUS > n = < INTEGER >    {      return new ASTInteger(-Integer.parseInt(n.image), ctx);    }    )  {}}/*** Assertions*/ASTNode AssertionOr(boolean is_negation) throws Exception :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = AssertionAnd(is_negation)  (    < OR > t2 = AssertionAnd(is_negation)    {      t1 = new ASTOr(t1, t2, ctx);    }  )*  {    return t1;  }  {}}ASTNode AssertionAnd(boolean is_negation) throws Exception :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = AssertionImplies(is_negation)  (    < AND > t2 = AssertionImplies(is_negation)    {      t1 = new ASTAnd(t1, t2, ctx);    }  )*  {    return t1;  }  {}}ASTNode AssertionImplies(boolean is_negation) throws Exception :{  ASTNode t1, t2;  Token n, n1, n2;}{  t1 = AssertionNot(is_negation)  (    < IMPLIES > t2 = AssertionNot(is_negation)    {      t1 = new ASTImplies(t1, t2, ctx); //ctx.mkImplies(t1.getAssertion(), t2.getAssertion());//new ASTImplies(t1, t2, ctx);    }  )?  {    return t1;  }  {}}ASTNode AssertionNot(boolean is_negation) throws Exception :{  ASTNode t, t1, t2;  Token n, n1, n2;}{  (    < NOT > t = AssertionComp(true)    {      return new ASTNot(t, ctx);    }  | t = AssertionComp(false)    {      return t;    }  )  {}}ASTNode AssertionComp(boolean is_negation) throws Exception :{  ASTNode t = null;  ASTNode t1, t2;  Token op, n, n1, n2;}{  t1 = AssertionArith(is_negation)  (    (      op = < EQUAL >    | op = < DIFF >    | op = < GREATER >    | op = < LESS >    | op = < GREATER_OR_EQUAL >    | op = < LESS_OR_EQUAL >    )    t2 = AssertionArith(is_negation) ///t2 = Exp()     {      if (op.kind == EQUAL) t1 = new ASTEqual(t1, t2, ctx);      if (op.kind == DIFF) t1 = new ASTDiff(t1, t2, ctx);      else if (op.kind == GREATER) t1 = new ASTGreater(t1, t2, ctx);      else if (op.kind == LESS) t1 = new ASTLess(t1, t2, ctx);      else if (op.kind == GREATER_OR_EQUAL) t1 = new ASTGreaterOrEqual(t1, t2, ctx);      else if (op.kind == LESS_OR_EQUAL) t1 = new ASTLessOrEqual(t1, t2, ctx);    }  )*  {    return t1;  }}ASTNode AssertionArith(boolean is_negation) throws Exception :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  t1 = AssertionString(is_negation)  (    (      op = < PLUS >    | op = < MINUS >    | op = < MULT >    | op = < DIV >    )    t2 = AssertionString(is_negation) ///t2 = Exp()     {      if (op.kind == PLUS) t1 = new ASTPlus(t1, t2, ctx);      else if (op.kind == MINUS) t1 = new ASTMinus(t1, t2, ctx);      else if (op.kind == MULT) t1 = new ASTMult(t1, t2, ctx);      else if (op.kind == DIV) t1 = new ASTDiv(t1, t2, ctx);    }  )*  {    return t1;  }}ASTNode AssertionString(boolean is_negation) throws Exception :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  t1 = AssertionGroup(is_negation)  (    < CONCAT > t2 = AssertionGroup(is_negation)    {      t1 = new ASTConcat(t1, t2, ctx);    }  )*  {    return t1;  }}ASTNode AssertionGroup(boolean is_negation) throws Exception :{  ASTNode t, t1, t2;  Token op, n, n1, n2;}{  (    < LPAR > t1 = AssertionOr(is_negation) < RPAR >  | t1 = AssertionCall(is_negation)  )  {    return t1;  }}ASTNode AssertionCall(boolean is_negation) throws Exception :{  ASTNode t, t1, t2 = null;  Token op, n, n1, n2;  MoolMethod m, method_called = null;}{  (    t = AssertionLiteral(is_negation)    (      < DOT > n = < ID > < LPAR > < RPAR >      {        if (parser_context) return t;		        String id = class_fields.get(t.toString());        if (id != null)        {          method_called = mool_classes.get(class_fields.get(t.toString())).getMethod(n.image);          MoolClass mc = mool_classes.get(class_name.image);                    if (constructor_context)          {                        m = mc.getClassConstructor();          } else          {                        //MoolMethod m = mc.getClassMethods().get(method_counter+1);                        Iterator< MoolMethod > method_it = mc.getClassMethods().iterator();						while(method_it.hasNext())			{				m = method_it.next();				if(m.getMethodName().equals(method_name))					break;			}            if(method_it.hasNext())				m = method_it.next();            else            	m = mc.getClassMethods().get(mc.getClassMethods().size() - 1);          }        }        else        {                    if (constructor_context)          {            MoolClass mc = mool_classes.get(class_name.image);                                    m = mc.getClassConstructor();            MoolField f = m.getMethodParameter(t.toString());           // System.out.println("JJGUHIHIH " + t.toString() + "     " + mc.getClassName() + "  " + f.getFieldName());                        if (f != null)            {              method_called = mool_classes.get(f.getFieldType()).getMethod(n.image);              //System.out.println("MOE  " +  mool_classes.get(f.getFieldType()).getMethod(n.image) );            }            else            {              f = m.getMethodVariable(t.toString());              if (f != null)              {                method_called = mool_classes.get(f.getFieldType()).getMethod(n.image);                              }              /*else              {                //throw new Exception();              }*/            }          }          else          {            MoolClass mc = mool_classes.get(class_name.image);            //MoolMethod m = mc.getClassMethods().get(method_counter+1);            			            Iterator< MoolMethod > method_it = mc.getClassMethods().iterator();						while(method_it.hasNext())			{				m = method_it.next();				if(m.getMethodName().equals(method_name))					break;			}            if(method_it.hasNext())				m = method_it.next();            else            	m = mc.getClassMethods().get(mc.getClassMethods().size() - 1);                       MoolField f = m.getMethodParameter(t.toString());                        if (f != null)            {              method_called = mool_classes.get(f.getFieldType()).getMethod(n.image);            }            else            {              f = m.getMethodVariable(t.toString());              if (f != null)              {                method_called = mool_classes.get(f.getFieldType()).getMethod(n.image);              }              /*else              {                throw new Exception();              }*/            }          }			                  }		t = new ASTCall(ctx, t.toString(), n.image, null, is_negation, m, method_called);      }    | < LPAR > < RPAR >      {        if (!parser_context) t = mool_classes.get("FileReader").getMethod(t.toString()).getMethodBody(); //ctx.mkBoolConst(n.image + "_call_on_" + t.toString());        else t = new ASTSkip(ctx);      }    )?  | < NEW > t = AssertionLiteral(is_negation) < LPAR > < RPAR >    {      mool_class = mool_classes.get(t.toString());      if (mool_class != null) t = mool_class.getClassInitialCondition(); //ctx.mkBoolConst(n.image + "_call_on_" + t.toString());    }  )  {    return t;  }}ASTNode AssertionLiteral(boolean is_negation) :{  ASTNode t, t1, t2;  Token n, n1, n2;}{  (    LOOKAHEAD(2)    n = < UNIT >    {      return new ASTSkip(ctx);    }  | n = < TRUE >    {      return new ASTTrue(ctx);    }  | n = < FALSE >    {      return new ASTFalse(ctx);    }  | n = < NULL >    {      return new ASTNull(ctx);    }  | n = < STRING >    {      return new ASTInteger(n.image.length(), ctx);    }  | n = < ID >    {      if (class_fields.containsKey(n.image)) return new ASTField(n.image, class_fields.get(n.image), false, null, ctx);      else if (local_variables.containsKey(n.image)) return new ASTField(n.image, local_variables.get(n.image), false, null, ctx);      else if (method_params.containsKey(n.image)) return new ASTField(n.image, method_params.get(n.image), false, null, ctx);      else if (mool_classes.containsKey(n.image)) return new ASTId(n.image, ctx);      else return new ASTId(n.image, ctx);    }  | n = < INTEGER >    {      return new ASTInteger(Integer.parseInt(n.image), ctx);    }  | < MINUS > n = < INTEGER >    {      return new ASTInteger(-Integer.parseInt(n.image), ctx);    }  )  {}}